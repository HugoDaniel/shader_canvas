<!DOCTYPE html>
<!-- Copyright 2021 Hugo Daniel Henriques Oliveira Gomes. All rights reserved.
Licensed under the EUPL -->
<html lang="en">

<head>
    <meta charset="utf-8">
    <link
        href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII="
        rel="icon" />
    <title>Shader Canvas New DSL Example</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <shader-canvas>
        <new-modules>
            <pan-zoom-2d>
                <webgl-program-part>
                    <vertex-shader>
                        <code-before>

                        // The values sent in this vec3 are:
                        // (x, y, scale)
                        uniform vec3 originAt;
                        uniform mat4 panZoomMatrix;
                        </code-before>
                    </vertex-shader>
                </webgl-program-part>
                <script type=module>
                    import { ShaderCanvas } from "../../build/shader_canvas.js";
                    import { transformPoint, identityMatrix, translate, scale, multiply } from "./matrix.js"

                    const module = ShaderCanvas.webglModule(() => {
                        const dpr = window.devicePixelRatio;
                        let rotation = 0;
                        let gestureStartRotation = 0;
                        let gestureStartZoom = 0;
                        let zoom = 1;
                        let zoomSign = 1;
                        let zoomDelta = 0;
                        let oldZoom = 0.99;
                        let panX = 0;
                        let panY = 0;
                        let oldPanX = 0;
                        let oldPanY = 0;
                        let startX;
                        let startY;
                        let mouseX = -1;
                        let mouseY = -1;
                        const wheelHandler = (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            if (e.ctrlKey) {
                                zoom = Math.max(0.1, zoom - e.deltaY * 0.1);
                                zoomSign = Math.sign(e.deltaY)
                            } else {
                                panX -= e.deltaX * 2;
                                panY -= e.deltaY * 2;
                            }
                        };
                        const mouseHandler = (e) => {
                            mouseX = e.clientX;
                            mouseY = e.clientY;
                        };
                        const gestureStartHandler = (e) => {
                            e.preventDefault();
                            startX = e.pageX - panX;
                            startY = e.pageY - panY;
                            gestureStartRotation = rotation;
                            gestureStartZoom = zoom;
                        };
                        const gestureChangeHandler = (e) => {
                            e.preventDefault();
                            rotation = gestureStartRotation + e.rotation;
                            zoom = gestureStartZoom * e.scale;
                            zoomSign = Math.sign(oldZoom - zoom)
                            panX = e.pageX - startX;
                            panY = e.pageY - startY;
                        };
                        const gestureEndHandler = (e) => e.preventDefault();
                        window.addEventListener("mousemove", mouseHandler);
                        window.addEventListener("wheel", wheelHandler,  { passive: false, capture: true });
                        window.addEventListener("gesturestart", gestureStartHandler);
                        window.addEventListener("gesturechange", gestureChangeHandler);
                        window.addEventListener("gestureend", gestureEndHandler);
                        let zoomT = identityMatrix();
                        let totalPanZoom = [0, 0, 1];
                        let isUpdateNeeded = true;
                        let firstRender = true;
                        const state = {
                            matrix: zoomT,
                            originAt: totalPanZoom,
                            _isUpdating: false,
                            _timeoutId: null,
                            get isUpdating() {
                                return this._isUpdating;
                            },
                            set isUpdating(value) {
                                if (value !== this._isUpdating) {
                                    if (value) {
                                        this._isUpdating = value;
                                        this.onActionStart();
                                    } else {
                                        this._isUpdating = value;
                                        // only call end action after a timeout
                                        // is reached
                                        if (this._timeoutId === null) {
                                            this._timeoutId = setTimeout(() => {
                                                this._timeoutId = null;
                                                if (!this._isUpdating) {
                                                    this.onActionEnd()
                                                }
                                            }, 40)
                                        }
                                    }
                                }
                            },
                            _actionStart: [],
                            get onActionStart() {
                                if (this._actionStart.length === 0) {
                                    return (() => {});
                                }
                                return (() => this._actionStart.forEach(f => f()))
                            },
                            _actionEnd: [],
                            set onActionStart(arg) {
                                if (typeof arg !== "function") {
                                    console.warn('A function was not passed to "onActionStart"');
                                    return;
                                }
                                this._actionStart.push(arg);
                            },
                            get onActionEnd() {
                                if (this._actionEnd.length === 0) {
                                    return (() => {})
                                }
                                return (() => this._actionEnd.forEach(f => f()))
                            },
                            set onActionEnd(arg) {
                                if (typeof arg !== "function") {
                                    console.warn('A function was not passed to "onActionEnd"');
                                    return;
                                }
                                this._actionEnd.push(arg);
                            }
                        };
                        // console.log('STATE', state)
                        return ({
                            getState() {
                                state.matrix = zoomT;
                                state.originAt = totalPanZoom;
                                return state;
                            },
                            onFrame() {
                                let updated = false;
                                if ((oldZoom !== zoom) || firstRender) {
                                    // Apply the zoom affine transformation matrix
                                    const centerX = mouseX * dpr;
                                    const centerY = mouseY * dpr;
                                    zoomDelta = Math.exp(Math.abs(zoom - oldZoom) * -zoomSign);
                                    const matrix = identityMatrix();
                                    translate(matrix, [centerX, centerY, 0.0], matrix);
                                    scale(matrix, [zoomDelta, zoomDelta, 0.0], matrix);
                                    translate(matrix, [-centerX, -centerY, 0.0], matrix);
                                    multiply(matrix, zoomT, matrix)
                                    zoomT = matrix;
                                    oldZoom = zoom;
                                    isUpdateNeeded = true;
                                    firstRender = false;
                                }
                                let transform = zoomT;
                                if (oldPanX !== panX || oldPanY !== panY) {
                                    // Apply the translation affine transformation matrix
                                    const factor = Math.PI / Math.exp(zoom);
                                    const deltaX = (panX - oldPanX) * factor;
                                    const deltaY = (panY - oldPanY) * factor;
                                    translate(transform, [deltaX, deltaY, 0.0], transform);
                                    oldPanX = panX;
                                    oldPanY = panY;
                                    isUpdateNeeded = true;
                                }
                                if (isUpdateNeeded) {
                                    totalPanZoom = [0, 0, 0];
                                    const identity = identityMatrix();
                                    transformPoint(zoomT, totalPanZoom, totalPanZoom);
                                    multiply(identity, zoomT, identity);
                                    totalPanZoom[2] = identity[0]; // real zoom
                                    isUpdateNeeded = false;
                                    updated = true;
                                }
                                state.isUpdating = updated;
                            },
                            onUseProgram({ gl }, program) {
                                const matrixLoc = program.uniformLocations.get("panZoomMatrix");
                                const originLoc = program.uniformLocations.get("originAt");
                                if (!matrixLoc) return;
                                if (originLoc) {
                                    gl.uniform3fv(originLoc, totalPanZoom);
                                }
                                gl.uniformMatrix4fv(matrixLoc, false, zoomT);
                            },
                        })
                    })
                    module.useWith("pan-zoom-2d");
                </script>
            </pan-zoom-2d>
        </new-modules>
        <webgl-canvas>
            <webgl-vertex-array-objects>
                <quad-vao>
                    <bind-buffer src="quad-vertices">
                        <vertex-attrib-pointer variable="position" size="4"></vertex-attrib-pointer>
                    </bind-buffer>
                    <bind-buffer src="quad-indices"></bind-buffer>
                    <bind-buffer src="quad-instance-scene">
                        <vertex-attrib-pointer variable="instanceScene" size="4" divisor="1">
                        </vertex-attrib-pointer>
                    </bind-buffer>
                </quad-vao>
            </webgl-vertex-array-objects>
            <webgl-buffers>
                <quad-vertices>
                    <buffer-data src="#points"></buffer-data>
                </quad-vertices>
                <quad-indices>
                    <buffer-data src="#elements" target="ELEMENT_ARRAY_BUFFER"></buffer-data>
                </quad-indices>
                <quad-instance-scene></quad-instance-scene>
                <position-picker-pack>
                    <!-- Fed by readPixels() -->
                    <buffer-data target="PIXEL_PACK_BUFFER" usage="STREAM_READ"></buffer-data>
                </position-picker-pack>
            </webgl-buffers>
            <webgl-textures>
                <picker-texture-target>
                    <tex-image-2d></tex-image-2d>
                    <tex-parameter-i pname="TEXTURE_MIN_FILTER" param="NEAREST"></tex-parameter-i>
                    <tex-parameter-i pname="TEXTURE_MAG_FILTER" param="NEAREST"></tex-parameter-i>
                </picker-texture-target>
            </webgl-textures>
            <webgl-framebuffers>
                <position-picker>
                    <!--
                    <framebuffer-texture-2d attachment="COLOR_ATTACHMENT0" src="picker-texture-target">
                    </framebuffer-texture-2d>
                -->
                    <framebuffer-renderbuffer attachment="COLOR_ATTACHMENT0">
                        <renderbuffer-storage format="RG32I"></renderbuffer-storage>
                    </framebuffer-renderbuffer>

                    <framebuffer-renderbuffer attachment="DEPTH_ATTACHMENT">
                        <renderbuffer-storage format="DEPTH_COMPONENT16"></renderbuffer-storage>
                    </framebuffer-renderbuffer>
                </position-picker>
            </webgl-framebuffers>
            <webgl-programs>
                <infinite-grid>
                    <pan-zoom-2d></pan-zoom-2d>
                    <vertex-shader>
                        <code>
                            #version 300 es
    
                            in vec4 position;
                            in vec4 instanceScene;
                            uniform mat4 projection; 
                            uniform float size;
    
                            out float sceneColorId;
                            out vec2 instancePos;
   
                            void main() {
                                vec4 vertex =
                                    vec4(size, size, 1.0, 1.0)
                                    * position
                                    + vec4(instanceScene.xy * vec2(size), 0.0, 0.0);

                                vec4 transformedVertex = panZoomMatrix * vertex;
                                vec4 projected = projection * transformedVertex;

                                gl_Position = projected;
                                sceneColorId = instanceScene.z;
                                instancePos = instanceScene.xy;
                            }
                        </code>
                    </vertex-shader>
                    <fragment-shader>
                        <code>
                            #version 300 es

                            precision highp float;

                            uniform vec3 hover;
                            uniform float isLines;
                            out vec4 outColor;
                            in vec2 instancePos;
                            in float sceneColorId;

                            vec4 getColorById(float cid) {
                                vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
                                if (cid == 1.0) {
                                    color = vec4(0.75, 0.25, 0.25, 1.0);
                                } else if(cid == 2.0) {
                                    color = vec4(0.35, 0.75, 0.25, 1.0);
                                } else if(cid == 3.0) {
                                    color = vec4(0.35, 0.25, 0.75, 1.0);
                                } else if(cid == 4.0) {
                                    color = vec4(0.75, 0.8, 0.25, 1.0);
                                } else if(cid == 5.0) {
                                    color = vec4(0.1, 0.2, 0.3, 1.0);
                                }
                                return color;
                            }
                            void main() {
                                vec4 color = getColorById(sceneColorId);
                                if (hover.xy == instancePos) {
                                    outColor = getColorById(hover.z); // vec4(0.8, 0.7, 0.6, 1);
                                } else {
                                    outColor = isLines * vec4(0.2, 0.2, 0.1, 1.0)
                                    + (color - isLines * color);
                                }
                            }
                        </code>
                    </fragment-shader>
                    <script type="module">
                        import { ShaderCanvas } from "../../build/shader_canvas.js";
                        import { ortho } from "./matrix.js"
                        import { VectorMap } from "./vector_map.js"
                        ////////////////////
                        // APP STATE MOCK //
                        ////////////////////
                        const appState = new VectorMap(
                            [[0, 0], [1, 1], [1, 2], [-1, -1], [2, 2], [5, 2], [5, 0], [10, 2], [31, 2], [0, 29]],
                            [5, 1, 2, 3, 4, 1, 3, 2, 5, 5]
                        )

                        const gridSettings = new Float32Array([
                            0, 0, 0, 0
                        ]);
                        ////////////////////
                        const drawElements = document.querySelectorAll("draw-vao");
                        const setInstanceCount = (instanceNumber) => {
                            for (const drawElem of drawElements) {
                                drawElem.setAttribute("instanceCount", instanceNumber)
                            }
                        }
                        const dpr = window.devicePixelRatio;
                        const w = window.innerWidth * dpr;
                        const h = window.innerHeight * dpr;
                        const size = 16; // In pixels - minimum size possible when zoomed out completely
                        const padding = 4; // Number of extra squares beyond the visible canvas
                        const horizontalSquares = Math.ceil((w / dpr) / size) + padding;
                        const verticalSquares = Math.ceil((h / dpr) / size) + padding;
                        const instances = horizontalSquares * verticalSquares;
                        const dim = 4; // Matrix dimension
                        const instanceScene = new Float32Array(instances * dim);
                        const cols = Math.ceil(w / (size * dpr)) + padding;
                        const dprSize = size * dpr;
                        let needsSceneUpdate = false;
                        let needsColorUpdate = false;

                        // its real indexes(x, y, fillId, fillRot)
                        function fillInstanceScene(gl, buffer, state = { originAt: [0, 0, 1] }) {
                            // padX, padY represent the number of pixels being
                            // panned. It can be seen as the distance of the
                            // current viewport towards the origin (with DPR).
                            // i.e. -170px in padX means that the origin is at
                            // 170/DPR pixels to the left. 
                            const transforms = state.originAt;
                            const scaledSize = dprSize * transforms[2];
                            const sceneDeltaX = Math.floor(transforms[0] / scaledSize) + padding / 2;
                            const sceneDeltaY = Math.floor(transforms[1] / scaledSize) + padding / 2;
                            for (let i = 0; i < instances; i++) {
                                const sceneX = Math.floor((i % cols) - sceneDeltaX);
                                const sceneY = Math.floor(Math.abs(i / cols) - sceneDeltaY);

                                instanceScene[dim * i + 0] = sceneX;
                                instanceScene[dim * i + 1] = sceneY;
                                instanceScene[dim * i + 2] = appState.getXY(sceneX, sceneY) || 0;
                            }
                            buffer.bindBuffer();
                            gl.bufferData(gl.ARRAY_BUFFER, instanceScene, gl.DYNAMIC_DRAW);
                        }

                        ShaderCanvas.initializeBuffers((gl, buffers) => {
                            const panZoomObj = ShaderCanvas.getModuleState("pan-zoom-2d");

                            const dataBuffers = [
                                buffers.content.get("quad-instance-scene")
                            ];
                            setInstanceCount(instances);
                            fillInstanceScene(gl, dataBuffers[0]);
                            return (() => {
                                const state = ShaderCanvas.getModuleState("pan-zoom-2d");
                                if (!state || !state.matrix || !state.originAt || !(state.matrix instanceof Float32Array) || !state.originAt instanceof Array) {
                                    console.log('Invalid "pan-zoom-2d" state');
                                    return;
                                }
                                if (panZoomObj.isUpdating || needsSceneUpdate) {
                                    fillInstanceScene(gl, dataBuffers[0], state);
                                    needsSceneUpdate = false;
                                }
                                if (needsColorUpdate) {
                                    colorId = Math.floor(Math.random() * 4) + 1
                                    needsColorUpdate = false;
                                }
                            })
                        });

                        let hoverX = undefined;
                        let hoverY = undefined;
                        let colorId = Math.floor(Math.random() * 4) + 1;
                        const p = ShaderCanvas.createProgram((gl, { uniformLocations, ctx }) => {
                            let oldHoverX = hoverX;
                            let oldHoverY = hoverY;
                            const hoverLoc = uniformLocations.get("hover");
                            gl.uniformMatrix4fv(uniformLocations.get("projection"), false,
                                ortho(0, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, 0, 1));
                            gl.uniform1f(uniformLocations.get("size"), dprSize);
                            return () => {
                                if (hoverX !== oldHoverX || hoverY !== oldHoverY) {
                                    gl.uniform3f(hoverLoc, hoverX, hoverY, colorId);
                                    oldHoverX = hoverX;
                                    oldHoverY = hoverY;
                                }
                            }
                        });

                        p.useWith("infinite-grid")

                        //////////////////////
                        // Picking code
                        //////////////////////

                        function picking() {
                            let mouseX = -1;
                            let mouseY = -1;
                            let isReading = false;
                            const pixels = document.querySelector("read-pixels");
                            const data = new Uint32Array(w * h * 4);

                            let reader = Promise.resolve(data);
                            const view = new DataView(data.buffer)
                            document.addEventListener("pointermove", (e) => {
                                mouseX = Math.floor(e.offsetX * dpr);
                                mouseY = h - Math.floor(e.offsetY * dpr);
                                const arrayPos = mouseY * (w * 16) + (mouseX * 16);
                                hoverX = view.getInt32(arrayPos, true);
                                hoverY = view.getInt32(arrayPos + 4, true);
                            }, { capture: true });

                            document.addEventListener("pointerdown", (e) => {
                                needsSceneUpdate = true;
                                needsColorUpdate = true;
                                appState.addXY(hoverX, hoverY, colorId);
                                // const sceneLinearPos = (instanceScene[0] - hoverX) * (instanceScene[1] - hoverY) * 4;
                                console.log(`Down(${instanceScene[0] - hoverX}, ${instanceScene[1] - hoverY})`)
                            })

                            // Get the read pixels:
                            const p = ShaderCanvas.createProgram((gl, { uniformLocations, ctx }) => {
                                const panZoomObj = ShaderCanvas.getModuleState("pan-zoom-2d");
                                // panZoomObj.onActionStart = () => console.log('STARTING PAN/ZOOM');
                                panZoomObj.onActionEnd = () => {
                                    pixels?.getPixels(data);
                                }

                                gl.uniform1f(uniformLocations.get("size"), 16 * dpr);
                                gl.uniformMatrix4fv(uniformLocations.get("projection"), false,
                                    ortho(0, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, 0, 1));
                            });
                            p.useWith("picking-render")
                        }

                        picking();
                    </script>
                </infinite-grid>
                <picking-render>
                    <pan-zoom-2d></pan-zoom-2d>

                    <vertex-shader>
                        <code>
                            #version 300 es
    
                            in vec4 position;
    
                            uniform float size;
                            uniform mat4 projection;    
    
                            in vec4 instanceScene;
                            flat out ivec2 pos;
    
                            void main() {
                                pos = ivec2(int(instanceScene.x),int(instanceScene.y));

                                vec4 vertex =
                                    vec4(size, size, 1.0, 1.0)
                                    * position
                                    + vec4(instanceScene.xy * vec2(size),
                                        0.0, 0.0);

                                vec4 transformedVertex = panZoomMatrix * vertex;
                                vec4 projected = projection * transformedVertex;

                                gl_Position = projected;
                            }
                        </code>
                    </vertex-shader>
                    <fragment-shader>
                        <code>
                            #version 300 es

                            precision highp float;

                            flat in ivec2 pos;

                            out ivec2 rg32;

                            void main() {
                                rg32 = pos;
                            }
                        </code>
                    </fragment-shader>
                </picking-render>
            </webgl-programs>
            <draw-calls>
                <clear-color red="1" green="0" blue="0" alpha="0"></clear-color>
                <clear-flags mask="COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT"></clear-flags>
                <draw-loop>
                    <bind-framebuffer src="position-picker">
                        <viewport-transform x="0" y="0"></viewport-transform>
                        <depth-func func="LEQUAL"></depth-func>
                        <use-program src="picking-render">
                            <draw-vao src="quad-vao" mode="TRIANGLE_FAN" count="4" type="UNSIGNED_SHORT"></draw-vao>
                        </use-program>
                        <read-pixels dest="position-picker-pack" type="INT" format="RGBA_INTEGER"></read-pixels>
                    </bind-framebuffer>
                    <viewport-transform x="0" y="0"></viewport-transform>
                    <depth-func func="LEQUAL"></depth-func>
                    <use-program src="infinite-grid">
                        <uniform-1fv var="isLines" value="0"></uniform-1fv>
                        <draw-vao src="quad-vao" mode="TRIANGLE_FAN" count="4" type="UNSIGNED_SHORT">
                        </draw-vao>
                        <uniform-1fv var="isLines" value="1"></uniform-1fv>
                        <draw-vao src="quad-vao" mode="LINE_STRIP" count="3" type="UNSIGNED_SHORT">
                        </draw-vao>
                    </use-program>
                </draw-loop>
            </draw-calls>
        </webgl-canvas>
    </shader-canvas>
    <div id="elements" style="display: none">
        [ 3, 2, 1, 0 ]
    </div>
    <div id="points" style="display: none">
        [
        0.0, 0.0, 0.5, 1.0,
        1.0, 0.0, 0.5, 1.0,
        1.0, 1.0, 0.5, 1.0,
        0.0, 1.0, 0.5, 1.0]
    </div>

    <!-- For triangles use these points and adjust the instance count:
                            <div id="points" style="display: none">
                                [ 0, 0, 0, 1,
                                1, 0, 0, 1,
                                0.5, 0.866, 0, 1
                                ]
                            </div>
                            <div id="elements" style="display: none">
                                [ 0, 1, 2, 0 ]
                            </div>
    -->
    <script type="module">
        import { ShaderCanvas } from "../../build/shader_canvas.js";
        window.addEventListener("load", () => {
            let c = document.querySelector("shader-canvas");
            if (c instanceof ShaderCanvas) {
                c.initialize().then(() => {
                    c.draw()
                })
            }
        })
    </script>
</body>

</html>