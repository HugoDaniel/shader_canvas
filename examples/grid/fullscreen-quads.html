<shader-canvas>
    <texture-atlas>
    </texture-atlas>
    <webgl-pieces>
        <animation-piece>
            <vertex-shader>
                <code>
                    uniform float PI;
                    uniform float iTime;
                    uniform float iDuration;
                    uniform float iAnimationDirection;
                    in float aShapeIndex;
                    in float aShapeDelay;
                    in float aShapeRevDelay;
                </code>
            </vertex-shader>
        </animation-piece>
    </webgl-pieces>
    <webgl-shaders>
        <fullscreen-quads>
            <animation-piece />
            <vertex-shader>
                <code>
                uniform float iOpenAmount;
                attribute vec4 aVertexPosition;
                attribute vec2 aTextureCoord;
                varying vec2 vTextureCoord;
                // varying float vFaceIndex;
                void main() {
                    // float openUntil = iOpenAmount;
                    // float deltaT = iTimeDelta;
                    // float animId = iAnimationId;
                    vec4 pos = aVertexPosition;
                    if (aShapeIndex <= iOpenAmount) {
                    if (iAnimationDirection == 1.0) {
                        float delay = aShapeDelay * 0.001;
                        float curTime = max(iTime, delay) - delay;
                        float param = min(curTime / iDuration, 1.0);
                        pos.y = pos.y + 2.0 * sin(param * 0.5 * PI);
                    } else {
                        float delay = aShapeRevDelay * 0.001;
                        float curTime = iTime + delay;
                        float param = min(curTime / iDuration, 1.0);
                        pos.y = pos.y + 2.0 * cos(param * 0.5 * PI);
                    }
                }
                    gl_Position = pos;
                    vTextureCoord = aTextureCoord;
                    // vFaceIndex = aShapeIndex;
                }
                </code>
            </vertex-shader>
            <texture-2d>
                <!-- uses the only defined sampler2D -->
                <webgl-shader src="square-grid" />
            </texture-2d>
            <fragment-shader>
                <code>
                    precision mediump float;
                    uniform sampler2D scene;
                    varying vec2 vTextureCoord;
                    void main() {
                        vec4 textureColor = texture2D(scene, vec2(vTextureCoord.s, vTextureCoord.t));
                        gl_FragColor = textureColor;
                    }
                </code>
            </fragment-shader>
        </fullscreen-quads>
        <square-grid>
            <!-- TODO: triangles generation, buffers declarations etc.. -->
            <vertex-shader>
                <code>
                    in vec3 aVertexPosition;
                    in float aVertexIdd;
                    in float aFaceIndex;
                    in vec4 aFaceTextureCoords;
                    in float aFaceRot;
                    uniform vec3 iResolution;
                    uniform float iUnitSize;
                    uniform vec2 iOffset;
                    uniform float iRenderingLines;
                    uniform float iRenderingCursor;
                    uniform float iCursorAt;
                    uniform vec4 iGridLineColor;
                    uniform vec4 iCursorColor;
                    out vec4 v_color;
                    out float fromTexture;
                    out vec2 v_texCoord;

                    vec2 rotate(vec2 v, float a, vec2 c) {
                        return vec2(
                            c.x + (v.x - c.x) * cos(a) - (v.y - c.y) * sin(a),
                            c.y + (v.x - c.x) * sin(a) + (v.y - c.y) * cos(a));
                    }

                    void main() {
                        float rot = aFaceRot;
                        float z = 0.0;
                        float vid = aVertexIdd;
                        float isRenderingLines = iRenderingLines;
                        vec4 lineColor = iGridLineColor;
                        float cursorAt = iCursorAt;
                        vec4 cursorColor = iCursorColor;
                        vec4 curTextureCoords = aFaceTextureCoords;
                        float face = aFaceIndex;
                        // code starts here:
                        v_color = vec4(0.0, 0.0, 0.0, 0.0);
                        fromTexture = 0.0;
                        v_color = iRenderingLines * iGridLineColor;
                        if (face == cursorAt && iRenderingCursor == 1.0) {
                            v_color = v_color + iRenderingCursor * iCursorColor;
                        } else
                        if ((curTextureCoords.w != -1.0) && iRenderingLines != 1.0) {
                            fromTexture = 1.0;
                            // calculate the texture coords
                            float faceVertexNum = vid - (face * 4.0);
                            v_texCoord = rotate(
                                vec2(
                                    curTextureCoords.x + mod(faceVertexNum, 2.0) * curTextureCoords.z,
                                    curTextureCoords.y + curTextureCoords.z - step(1.5, faceVertexNum) * curTextureCoords.z),
                                -2.0 * 3.14156 * (aFaceRot),
                                vec2(
                                    curTextureCoords.x + (curTextureCoords.z / 2.0),
                                    curTextureCoords.y + curTextureCoords.z - (curTextureCoords.z / 2.0)
                                ));
                        }
                        vec2 len = vec2(
                            iUnitSize * 2.0 / iResolution.x,
                            iUnitSize * 2.0 / iResolution.y
                        );
                        vec2 numSquares = ceil((iResolution.xy / vec2(iUnitSize, iUnitSize))) + vec2(2.0, 2.0);
                        vec2 off = iOffset;
                        float offX = mod((iOffset.x / iResolution.x) * 2.0, len.x);
                        float offY = mod((iOffset.y / iResolution.y) * 2.0, len.y);
                        float faceX = -1.0 + mod(face, (numSquares.x)) * len.x - len.x / 2.0 - offX;
                        float faceY = -1.0 + ceil(face / (numSquares.x)) * len.y - len.y / 2.0 - offY;
                        float x = faceX + aVertexPosition.x * len.x / 2.0;
                        float y = faceY + aVertexPosition.y * len.y / 2.0;
                        float faceVisible = step(face, (numSquares.x) * (numSquares.y));
                        gl_Position = vec4(x, -y, z, faceVisible);
                    }
                </code>
            </vertex-shader>
            <fragment-shader>
                <code>
                    precision mediump float;
                    uniform sampler2D texture;
                    in float fromTexture;
                    in vec4 v_color;
                    in vec2 v_texCoord;
                    void main() {
                        vec4 textureColor = texture2D(texture, v_texCoord);
                        gl_FragColor = (1.0 - fromTexture) * v_color + fromTexture * textureColor;
                    }
                </code>
            </fragment-shader>
        </square-grid>
        <simple-triangle>
            <vertex-shader>
                <code>
            #version 300 es
            in vec4 a_position;
            void main() {
                gl_Position = a_position;
            } 
            </code>
            </vertex-shader>
            <fragment-shader>
                <code>
            #version 300 es
            precision highp float;
            out vec4 outColor;

            void main() {
                outColor = vec4(0, 0, 0.5, 1);
            }    
            </code>
            </fragment-shader>
        </simple-triangle>
    </webgl-shaders>
</shader-canvas>